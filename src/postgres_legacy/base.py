from __future__ import unicode_literals

from psycopg2 import ProgrammingError

from django.db.backends.postgresql_psycopg2.base import DatabaseWrapper as OrigDatabaseWrapper
from django.db.backends.postgresql_psycopg2.base import DatabaseOperations as OrigDatabaseOperations


def get_sequence_name(cursor, table_name, pk_name):
    """Fetch the sequence name of an auto-incrementing field

    Looks up the information_schema
    """
    query = """SELECT column_default
        FROM information_schema.columns
        WHERE table_name = %s AND column_name = %s;"""
    cursor.execute(query, (table_name, pk_name))
    result = cursor.fetchone()
    if result is None:
        return None
    return result[0].split("'")[1]


class DatabaseOperations(OrigDatabaseOperations):

    def last_insert_id(self, cursor, table_name, pk_name):
        "Try fetching existing sequence, else generate as per standard django"
        seq_name = get_sequence_name(cursor, table_name, pk_name)
        cursor.execute("SELECT CURRVAL(%s)", (seq_name,))
        return cursor.fetchone()[0]

    def sequence_reset_by_name_sql(self, style, sequences):
        # 'ALTER SEQUENCE sequence_name RESTART WITH 1;'... style SQL statements
        # to reset sequence indices
        sql = []
        for sequence_info in sequences:
            table_name = sequence_info['table']
            column_name = sequence_info['column']
            if not (column_name and len(column_name) > 0):
                # This will be the case if it's an m2m using an autogenerated
                # intermediate table (see BaseDatabaseIntrospection.sequence_list)
                column_name = 'id'
            seq_name = get_sequence_name(self.cursor, table_name, column_name)
            sql.append("%s setval('%s', 1, false);" %
                (style.SQL_KEYWORD('SELECT'),
                seq_name)
            )
        return sql

    def sequence_reset_sql(self, style, model_list):
        from django.db import models
        output = []
        qn = self.quote_name
        for model in model_list:
            # Use `coalesce` to set the sequence for each model to the max pk value if there are records,
            # or 1 if there are none. Set the `is_called` property (the third argument to `setval`) to true
            # if there are records (as the max pk value is already in use), otherwise set it to false.
            # Use get_sequence_name() instead of pg_get_serial_sequence to get the underlying sequence name

            for f in model._meta.local_fields:
                if isinstance(f, models.AutoField):
                    table_name = model._meta.db_table
                    column_name = f.column
                    seq_name = get_sequence_name(self.cursor, table_name, column_name)
                    output.append("%s setval('%s', coalesce(max(%s), 1), max(%s) %s null) %s %s;" %
                        (style.SQL_KEYWORD('SELECT'),
                        seq_name,
                        style.SQL_FIELD(qn(column_name)),
                        style.SQL_FIELD(qn(column_name)),
                        style.SQL_KEYWORD('IS NOT'),
                        style.SQL_KEYWORD('FROM'),
                        style.SQL_TABLE(qn(table_name))))
                    break  # Only one AutoField is allowed per model, so don't bother continuing.
            for f in model._meta.many_to_many:
                if not f.rel.through:
                    table_name = f.m2m_db_table()
                    column_name = 'id'
                    seq_name = get_sequence_name(self.cursor, table_name, column_name)
                    output.append("%s setval('%s', coalesce(max(%s), 1), max(%s) %s null) %s %s;" %
                        (style.SQL_KEYWORD('SELECT'),
                        seq_name,
                        style.SQL_FIELD(qn(column_name)),
                        style.SQL_FIELD(qn(column_name)),
                        style.SQL_KEYWORD('IS NOT'),
                        style.SQL_KEYWORD('FROM'),
                        style.SQL_TABLE(qn(table_name))))
        return output


class DatabaseWrapper(OrigDatabaseWrapper):

    def __init__(self, *args, **kwargs):
        super(DatabaseWrapper, self).__init__(*args, **kwargs)
        self.ops = DatabaseOperations(self)
